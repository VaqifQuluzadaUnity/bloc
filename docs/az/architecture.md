# Arxitektura

![Bloc Arxitekturası](../assets/bloc_architecture.png)

Bloc-un istifadəsi bizə tətbiqimizi 3 təbəqəyə bölməyə imkan verir:

- Data
  - Data Provider
  - Repository
- Business Logic
- Presentation

Ən aşağı təqəbədən (istifadəçi interfeysinə ən uzaq olan) başlayırıq və yolumuzu presentation təbəqəsinə qədər davam etdirəcəyik.

## Data Təbəqəsi

> Data təbəqəsinin öhdəliyi bir və yaxud çox mənbədən gələn dataların əldə edilməsi və manipulyasiya edilməsidir.

Data təbəqəsi 2 hissəyə bölünə bilər:

- Repository
- Data Provider

Bu təbəqə tətbiqin ən aşağı səviyyəsidir və database-lər, şəbəkə sorğuları və başqa asinxron data mənbələri ilə əlaqə yaradır.

### Data Provider

> Data provider-in öhdəliyi xam datanı (raw data) təmin etməkdir. Data provider ümumi və çox yönlü olmalıdır.

Data provider adətən [CRUD](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete) əməliyyatlarını yerinə yetirmək üçün sadə API-lar təmin edir.
Data layer-in bir hissəsi kimi, `createData`, `readData`, `updateData`, və `deleteData` kimi metodlarımız ola bilər.

```dart
class DataProvider {
    Future<RawData> readData() async {
        // Read from DB or make network request etc...
    }
}
```

### Repository

> Repository təbəqəsi Bloc layer-in əlaqə saxladığı və içərisində bir və ya daha çox data provider-i əhatə edən təbəqədir.

```dart
class Repository {
    final DataProviderA dataProviderA;
    final DataProviderB dataProviderB;

    Future<Data> getAllDataThatMeetsRequirements() async {
        final RawDataA dataSetA = await dataProviderA.readData();
        final RawDataB dataSetB = await dataProviderB.readData();

        final Data filteredData = _filterData(dataSetA, dataSetB);
        return filteredData;
    }
}
```

Gördüyünüz kimi, repository təbəqəsi çoxlu sayda data provider-lərlə əlaqə saxlaya və data-ları məntiqi kodlar olan hissəyə (Bloc-a) ötürməmişdən əvvəl onlar üzərində dəyişikliklər apara bilər.

## Bloc (Business Logic) Təbəqəsi

> The bloc layer's responsibility is to respond to events from the presentation layer with new states. The bloc layer can depend on one or more repositories to retrieve data needed to build up the application state.

Think of the bloc layer as the bridge between the user interface (presentation layer) and the data layer. The bloc layer takes events generated by user input and then communicates with repository in order to build a new state for the presentation layer to consume.

```dart
class BusinessLogicComponent extends Bloc<MyEvent, MyState> {
    final Repository repository;

    Stream mapEventToState(event) async* {
        if (event is AppStarted) {
            try {
                final data = await repository.getAllDataThatMeetsRequirements();
                yield Success(data);
            } catch (error) {
                yield Failure(error);
            }
        }
    }
}
```

### Bloc-to-Bloc Communication

> ​Every bloc has a state stream which other blocs can subscribe to in order to react to changes within the bloc.

Blocs can have dependencies on other blocs in order to react to their state changes. In the following example, `MyBloc` has a dependency on `OtherBloc` and can `add` events in response to state changes in `OtherBloc`. The `StreamSubscription` is closed in the `close` override in `MyBloc` in order to avoid memory leaks.

```dart
class MyBloc extends Bloc {
  final OtherBloc otherBloc;
  StreamSubscription otherBlocSubscription;

  MyBloc(this.otherBloc) {
    otherBlocSubscription = otherBloc.listen((state) {
        // React to state changes here.
        // Add events here to trigger changes in MyBloc.
    });
  }

  @override
  Future<void> close() {
    otherBlocSubscription.cancel();
    return super.close();
  }
}
```

## Presentation Layer

> The presentation layer's responsibility is to figure out how to render itself based on one or more bloc states. In addition, it should handle user input and application lifecycle events.

Most applications flows will start with a `AppStart` event which triggers the application to fetch some data to present to the user.

In this scenario, the presentation layer would add an `AppStart` event.

In addition, the presentation layer will have to figure out what to render on the screen based on the state from the bloc layer.

```dart
class PresentationComponent {
    final Bloc bloc;

    PresentationComponent() {
        bloc.add(AppStarted());
    }

    build() {
        // render UI based on bloc state
    }
}
```

So far, even though we've had some code snippets, all of this has been fairly high level. In the tutorial section we're going to put all this together as we build several different example apps.
